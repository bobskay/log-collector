[{"title":"centos安装","createTime":"2019-02-03 10:33:55","categories":["运维"],"tags":["centos","linux","visualbox"],"content":"通过sualbox安装centos<!--more-->目录#虚拟机根目录E:\\visualbox#最小化centos备份E:\\visualbox\\centosmin.bak# 初始化## 账号root:rootming:ming## 远程登录ip addr|grep 192.168# 设置yum源#直接删除,不备份了rm -rf /etc/yum.repos.d/*cp /media/sf_linux/etc/yum.repos.d/* /etc/yum.repos.d/#修改内容为E:\\linux\\Centos-7.repo#更新 yum update 可能比较久yum clean allyum makecacheyum update -y# 安装visualbox增强工具更新内核#安装一些该工具包yum -y install vimyum -y install lrzszyum -y install net-toolsyum -y install lsof#根据/media/VBoxLinuxAdditions.run的执行结果提示,安装所需部件yum -y install gccyum install kernel-devel gcc -yyum install bzip2 -y#重启reboot安装VBoxGuestAdditions#将E:\\linux\\VBoxGuestAdditions.iso拖到/root/下#挂载mount /root/VBoxGuestAdditions.iso /media/#mount: /dev/loop0 写保护，将以只读方式挂载#安装增强工具/media/VBoxLinuxAdditions.run分配共享目录挂载共享目录#重启后自动挂载到/media/sf_linux#创建目标目录#mkdir /win#-t 文件系统#mount -t vboxsf linux /win# 复制将E:\\visualbox\\bak\\centosmin.vdi复制到E:\\visualbox ,改名node01.kube.wang.vdi新建时选择刚才复制的文件设置网络为桥接远程登录#重启网络systemctl restart network#查看ipip addr|grep 192.168命令行启动systemctl set-default multi-user.target设置hostnamehostnamectl set-hostname node2修改为静态ip#192.168.1.201为要设置的ip#需确认网络已经设置为桥接，网卡名称如果不是enp0s3，需要删除原来配置，并修改文件里的NAME和DEVICE#重启cat /media/sf_linux/etc/sysconfig/network-scripts/ifcfg-enp0s3 | sed \"s/192.168.1.200/192.168.1.114/\" > /etc/sysconfig/network-scripts/ifcfg-enp0s3systemctl restart network修改启动命令vim ~/.bashrcifcfg-enp0s3内容TYPE=\"Ethernet\"PROXY_METHOD=\"none\"BROWSER_ONLY=\"no\"#$BOOTPROTO=\"dhcp\"BOOTPROTO=\"static\"IPADDR=192.168.1.200NETMASK=255.255.255.0GATEWAY=192.168.1.1DNS1=8.8.8.8DEFROUTE=\"yes\"IPV4_FAILURE_FATAL=\"no\"IPV6INIT=\"yes\"IPV6_AUTOCONF=\"yes\"IPV6_DEFROUTE=\"yes\"IPV6_FAILURE_FATAL=\"no\"IPV6_ADDR_GEN_MODE=\"stable-privacy\"NAME=\"enp0s3\"UUID=\"b6317c3a-28b1-4d40-a097-d8e63f285948\"DEVICE=\"enp0s3\"ONBOOT=\"yes\"<!--more-->","filePath":"E:\\linux\\blog\\src\\main\\nodejs\\blog\\_posts\\centos安装.md","url":"/blog/运维/centos安装/"},{"title":"hexo搭建个人博客","createTime":"2018-07-29 17:27:11","categories":["编码"],"tags":["hexo"],"content":"记录这个博客搭建过程，目前为止用到的功能如下，不断丰富中1. [hexo](https://hexo.io/zh-cn/)生成代码2. [next](http://theme-next.iissnan.com/)主题3. [码云](https://gitee.com/)web服务4. [leancloud](https://leancloud.cn/)记录阅读量编译并提交e:cd E:\\blog\\public\\bloghexo ggit add .git commit -am '备注'git push<!--more--># 准备工作这些工作因为以前就做过了，这里就不专门写出来了，1. 安装npm（Node Package Manager ），我的版本是5.6.02. 安装TortoiseGit，我的版本是TortoiseGit 2.6.0.03. 注册码云账号，并创建项目，这里定的项目名称是blog4. 本地新建目录，我用的是：E:\\blog，下面如果没特殊说明，所有命令均是在这个目录下执行的下面正式开始进入工作目录E:cd blog# 安装hexonpm install -g hexo# 创建项目hexo init启动，如果不行就执行一下npm installhexo s打开浏览器,在地址栏输入输入：http://127.0.0.1:4000/ 就可以直接访问了# 更换主题个人选的是[NexT](https://github.com/theme-next/hexo-theme-next)可以到网站上将其下载到主题目录E:\\blog\\themes，也可以直接用git命令git clone https://github.com/theme-next/hexo-theme-next.git themes/next修改项目根路径下的配置文件（e:/blog/_config.yml，后面简称站点文件）将theme改为next# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next修改next的配置文件（E:/blog/themes/next/_config.yml，后面简称主题文件）还可以进一步更换样式,目前可选的有下面这些，根据个人喜好，可自行选择# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini# 基础配置## 标题title: 个人博客## 语言language: zh-CN语言是和这个目录下的文件对应的：E:\\blog\\themes\\next\\languages## 添加分类和标签### 新建页面hexo new page categorieshexo new page tage### 修改生成页面的内容E:\\blog\\source\\categories\\index.md---title: 分类date: 2018-07-30 00:12:56type: \"categories\"---E:\\blog\\source\\tags\\index.md---title: 标签date: 2018-07-30 00:13:55type: \"tags\"---### 修改主题文件根据需要选择要显示的页面，因为分类和标签对个人比较有用，就先开放这两个menu:home: / || home#about: /about/ || usertags: /tags/ || tagscategories: /categories/ || th#archives: /archives/ || archive#schedule: /schedule/ || calendar#sitemap: /sitemap.xml || sitemap#commonweal: /404/ || heartbeat# 开始撰写写博客唯一要做的事就是在这个目录（E:\\blog\\source\\_posts）下新建md文件除了头部有一些特殊要求外，其余部分基本可以自由发挥## 头部信息文章标题和分类等信息需要按专门的格式写---title: 文章标题date: 2018-07-29 22:48:10categories: [一级分类,二级分类]tags: [标签1,标签2]---## 文章主体通过more便签可以将文正分为简介和正文两部分，下面是一个简单示例这里是内容简介，点击阅读全文可以看到更多内容<!--more--># 这里是一级标题## 测试画图'``flowst=>start: 开始op=>operation: 操作cond=>condition: 判断en=>end: 结束st->opop->condcond(yes)->en'``## 测试二级标题# 一级标题2# 一级标题3# 实际效果## 首页## 阅读全文## 分类## 标签# 发布到网上由于网速问题原因，我暂时未将项目发布到[github](https://github.com/)，而是用了[码云](https://gitee.com/)码云上提供了一个免费的Gitee Pages服务，可以用于展示静态页面只要在项目里点击服务，然后点击Gitee Pages，再启动就可以了## 修改项目根路径项目取名叫blog，所以最终发布到网上的网址为https://xixhaha.gitee.io/blog/为了保证页面和和资源能正常访问，需要对路径做一些修改## 修改网站文件将root改为/blogroot: /blog## 下载项目到本地我下载到了这个目录：E:/blog/public/bloggit clone https://gitee.com/xixhaha/blog.git public/blog## 修改生成目录因为这个目录E:/blog/public/blog将会是最终的发布目录，所以要将生成的静态页面都放这里修改站点文件public_dir: public/blog## 生成静态页面hexo g## 提交到网站用的是TortoiseGit ，所以只需要在blog目录按右键选择git commit就可以了### commit填写备注，随便写点什么，然后点击All和Commit### pushcommit后会转到push界面，直接点push换成命令就是e:cd E:\\blog\\public\\bloghexo ggit add .git commit -am '备注'git push# 总结基本上这样个人的博客就算搭建完毕了，以后要撰写博客只需要进行以下几个步骤1. 在E:\\blog\\blog\\_posts目录下新建md文件2. 开始撰写文章3. 执行命令 hexo g4. git commit and git push# 个性化配置## 按分类生成路径文章的链接地址默认是按日期生成的，这样当要链接到自己文章时不太方便，可以改为按分类生成修改网站文件permalink: :category/:title/## 排序规则默认是按发布时间倒序的，这里改成了按更新时间index_generator:path: ''per_page: 10order_by: -updated## 图片问题因为我将图片全放到了E:\\blog\\source\\images目录下，所以在外网访问时图片的路径是这个样子的/blog/images/1532877733213.png为了保证撰写文章时图片也能正常显示所以需要做一些调整将网站配置源文件目录改为blogsource_dir: blog每次插入图片时将图片复制到E:\\blog\\blog\\images我用的markdown编辑器是[typroa](https://www.typora.io/)需要在头部做一些配置，这样就保证能本地链接的地址和网站地址一致，同时在每次插入图片时自动复制到指定目录最终每次创建md文件时，都需要这么一个文件头---title:date:categories: []tags: []typora-copy-images-to: ../imagestypora-root-url: E:/blog/---写了一个文件（blog.py）专门干这事，每次要写博客的时候只要双击这个文件就可以了# -*- coding: UTF-8 -*-import datetimeimport subprocessimport threadingnow = datetime.datetime.now()fileName= now.strftime(\"%Y%m%d%H%M%S\")now = now.strftime(\"%Y-%m-%d %H:%M:%S\")head='''---title:date: {}categories: []tags: []typora-copy-images-to: ../imagestypora-root-url: E:/blog---<!--more-->'''.format(now)fileName='E:/blog/blog/_posts/'+fileName+'.md'fileHandle = open (fileName, 'w' )fileHandle.write (head)fileHandle.close()print(\"创建文件:\"+fileName)cmd=\"cmd /c D:/Typora/Typora.exe \"+fileNamedef action():subprocess.call(cmd,shell=True,stdout=subprocess.PIPE)t=threading.Thread(target=action)t.start()# 插件## markdown画图原始的hexo是不支持作图的，需要安装插件，目前试了只有流程图能用npm install --save hexo-filter-flowchart其它类型的图，暂时只能通过截图方式。。。## 站内搜索我大部分时间拿博客当云笔记用，所以搜索功能必不可少，幸好有插件实现了站内搜索功能### 安装插件npm install hexo-generator-searchdb --save### 修改站点文件search:path: search.xmlfield: postformat: htmllimit: 10000### 修改主题文件local_search:enable: true### 最终效果## 阅读次数next内部已经集成了leancloud，我们要做的只是开启这个功能### 修改主题文件将leancloud_visitors.enable设true，并配置app_id和app_key，这两个值需要到leancloud上获取leancloud_visitors:enable: trueapp_id: XXXXXXXXXXXapp_key: XXXXXXXXXXXXXXX### 注册并登录leancloud略### 创建应用点击头像-->点击应用按钮-->创建新应用输入应用名，点击创建### 创建Class选择刚才创建的应用后，点击云存储-->创建class-->输入class名称-->创建class这里名称要写**Counter**### 获取app_id和app_key将设置-->应用Key下的App ID和App Key写到上面说的主题文件里面### 发布应用e:cd E:\\blog\\public\\bloghexo ggit add .git commit -am '新增显示阅读次数功能'git push### 最终效果访问网页后点击Counter可以查看实际存储的数据的值，time就是保存的阅读次数，可以随意修改## 评论# 可能遇到问题## 无法删除文件某些情况下会发现.md文件已经删除了，但最终还是会生成html，这时候需要清一下缓存。但clean命令会将整个public目录删掉，git信息也没了，所以需要先备份一下，具体命令如下cd E:\\blogren E:\\blog\\public public1hexo cleanren E:\\blog\\public1 publichexo g## 404代码刚发布立即访问，有可能遇到临时无法访问的情况。如果不是这个原因，确认一下代码是否提交了，使用TortoiseGit，默认是不提交新增文件的，所以commit前记得点一下All## Template render error生成html页面的时候报错可能原因是md文件里写了这样的代码{#xxx}解决办法，想我这样写在代码块里就好了","filePath":"E:\\linux\\blog\\src\\main\\nodejs\\blog\\_posts\\hexo搭建blog.md","url":"/blog/编码/hexo搭建blog/"},{"title":"rocketmq个人定制","createTime":"2018-08-15 11:15:56","categories":["编码"],"tags":["rocketmq"],"content":"由于网络和性能因素，rocketmq对于重复消费，顺序消费，以及事务消息的解决方案，就是不解决。客户端根据自身业务情况，需要在一致性和可用性之间做出取舍，自己给出方案<!--more-->我的方案是分别在发送方和消费方创建2张表：发送表和消费表，通过本地事务的方式解决。同时对于每个topic，新增一个结果确认的消息，发送方发送消息同时，需要消费这个结果确认的topic。大体流程1. 发送方往发送表插入记录，并生成sendid2. 发送方执行业务代码，如果成功就往MQ发送消息，如果失败则回滚事务3. 消费方收到消息后，往消费表插入记录，由于sendId做了唯一约束，如果插入失败，表明已经消费过了4. 插入成功后执行业务代码5. 业务本身的成功和失败，直接更新消费表6. 如果出现异常，回滚事务，相当于没消费7. 消费成功往MQ发送结果8. 发送方收到消费结果，更新发送表，本次消费结束# 发送## 流程图st=>start: 准备发送beginTx=>subroutine: 开启事务preSend=>operation: 插入发送表preSendResult=>condition: 插入结果sendFail=>end: 结束sendBus=>operation: 业务代码sendBusResult=>condition: 执行结果commitTx=>subroutine: 提交事务rollbackTx=>subroutine: 回滚事务sendMessage=>end: 发送消到MQst->beginTx->preSend->preSendResultpreSendResult(no)->rollbackTx->sendFailpreSendResult(yes)->sendBus->sendBusResultsendBusResult(yes)->commitTx->sendMessagesendBusResult(no)->rollbackTx->sendFail## 异常点由于执行的是本地事务，所以只要消息表里有记录，就说明业务成功了，需要发送消。如果没记录，就说明不需要发。唯一异常原因是消息没发送到MQ，这个问题可以等到消息确认环节再解决。# 接收## 流程图st=>start: 收到消息beginTx=>subroutine: 开始事务insertConsumer=>operation: 插入消费表insertReslut=>condition: 插入结果ignore=>end: 重复消息,忽略consumerBus=>operation: 业务代码consumerResult=>condition: 执行成功commitTx=>subroutine: 提交事务rollTx=>subroutine: 回滚事务consumerFail=>end: 系统异常,当做未消费处理consumerSuccess=>operation: 消费成功,记录业务状态sendResult=>operation: 向MQ发送消费结果st->beginTx->insertConsumer->insertReslutinsertReslut(no)->ignoreinsertReslut(yes)->consumerBus->consumerResultconsumerResult(yes)->commitTx->consumerSuccess->sendResultconsumerResult(no)->rollTx->consumerFail## 异常点业务自身结果，例如余额不足，库存不足等情况，属于业务状态，这种情况当做消费成功处理，只需要把结果通知到生产方就好了。只有出现了未知 错误的时候，消息表和业务一起回滚，等待消息重发。非业务的因素的异常，就是成功消费后，未成功向mq发送结果，这个情况和发送时的异常一样，可以等到确认环节处理# 结果确认## 流程图st=>start: 收到消费结果cond=>condition: 业务是否成功success=>operation: 更新发送表end=>end: 流程结束rollback=>subroutine: 执行反向业务,更新发送表st->condcond(yes)->success->endcond(no)->rollback->end## 异常点这个地方对于MQ来说不存在异常的的情况# 补偿机制综上所述，对于MQ来说，所有因网络因素造成的消息未成功到达的情况，最终汇总后的结果都是发送表里的数据长期没有消费记录所以要做的就是查询发送表里的超过一定时间，无消费结果的数据，向消费方发起查询。在主动查询的的情况下，只要不是服务器全部宕机，总能获取结果的，根据查询结果- 如果是消费方未收到消息，就重发- 如果消费方一直消费失败，发送预警，人工介入- 已经有结果，直接更新记录# 具体实现## producer- 在业务入口添加SendMessage注解- 业务在需要发送某种消息的时候只需要调用msgService.send将数据插入消息表- msgService.send除了往数据库插入数据外，还会将插入的记录放一份到当前线程- 被SendMessage注解的方法结束，系统会从当前线程取出在此期间插入的消息，自动往mq发送消息@Transactional@SendMessagepublic OrderInfo insert(Long userId, Long bookId, Integer amount) {long orderId = newId();OrderCreateMsg orderMsg = new OrderCreateMsg();orderMsg.setBookId(bookId);orderMsg.setAmount(amount);orderMsg.setOrderId(orderId);Long orderSendId = msgService.send(orderMsg);//插入订单创建消息EmailMsg email = new EmailMsg();email.setContent(\"购买图书:\" + bookId);email.setBusId(orderId + \"\");email.setSubject(\"准备购买图书\");email.setToAddress(\"xxxxx@xxxx.com\");Long emailMsId = msgService.send(email);//插入邮件消息OrderInfo order = new OrderInfo();order.setBookMsId(orderSendId);order.setEmailMsId(emailMsId);order.setCreateTime(new Date());order.setOrderId(orderId);order.setUserId(userId);order.setBookId(bookId);order.setAmount(amount);orderDao.insert(order);return order;}系统在创建一个topic的时候，会自动创建一个叫%RESULT%XXX的topic，这个功能在我自己写的rocketmq管理界面里实现了produer决定往某个topic发送消息的时候，会通过push的方式消费这个topic对应的%RESULT%topic。## consumer消费者在监听到消息后，进入主业务方法- 在这个方法上标注ConsumerMessage- 业务方通过msgService.prepare判断消费是否重复消费- 消费结束后通过msgService.consumer更新消费结果- 系统在ConsumerMessage标记的方法结束后，会从当前线程取出消费过的消息，往MQ里发送消费结果@ConsumerMessage@Transactionalpublic void sendEmail(MessageExt msg) throws Exception {log.debug(\"收到邮件消息:\" + jsonUtil.toString(msg));EmailMsg email = msgService.prepare(msg, EmailMsg.class, true);//锁定if (email == null) {return;}ConsumerResult result = ConsumerResult.UNKNOWN;try {result = doBussiness(email);} finally {switch (result) {case SUCCESS:case ROLLBACK:msgService.consumer(msg, email, result, true);//确认break;case UNKNOWN:throw new RuntimeException(\"回滚事务,当做未消费处理\");default:break;}}}## 定时任务produer需启动一个定时任务，定期查询超过一定时间，还无消费结果记录。SELECT * FROM m_msgsend WHERE createTime<TIMESTAMPADD(MINUTE,-10,NOW()) AND msgConsumerId IS NULLconsumer端启动的时候，会自动启动一个服务，用于监听那些来查询消费结果的请求，这个用rocketmq封装的org.apache.rocketmq.remoting.netty.NettyRemotingServer实现private NettyRemotingServer server;public MsgConfirmServer(int threadNum,String host,int port,MsgService msgService,KvConfigService kvConfigService) {this.executorService =Executors.newFixedThreadPool(threadNum, new ThreadFactoryImpl(\"MsgConfirmServer_\"));NettyServerConfig config=new NettyServerConfig();config.setListenPort(port);server=new NettyRemotingServer(config);//设置请求执行类server.registerDefaultProcessor(new MsgConfirmProcessor(msgService), executorService);this.kvConfigService=kvConfigService;this.address=host+\":\"+port;}MsgConfirmProcessor里的实现，就是简单的通过sendId查找消费结果public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws Exception {MsgConsumerHeader requestHeader = (MsgConsumerHeader) request.decodeCommandCustomHeader(MsgConsumerHeader.class);//查找通过发送id查找消费结果,如果没有记录说明还没被消费MsgConsumer consumer=msgService.getBySendId(requestHeader.getSendId());MsgConfirm confirm=new MsgConfirm();if(consumer!=null) {confirm.setBusState(consumer.getBusState());confirm.setMsgConsumerId(consumer.getMsgConsumerId());}//封装结果final RemotingCommand response = RemotingCommand.createResponseCommand(null);byte[] content = confirm.encode();response.setBody(content);response.setCode(ResponseCode.SUCCESS);response.setRemark(null);return response;}封装请求的MsgConsumerHeader对象，里面只需要一个sendId参数@Datapublic class MsgConsumerHeader implements CommandCustomHeader{//消息发送idprivate Long sendId;@Overridepublic void checkFields() throws RemotingCommandException {}}# 顺序消费通过以上的方案解决了重复消费，和最终一致性的问题。至于顺序消费，不太严格的情况下，只要将消息按key做分类，MessageQueue本身是有顺序的，通常请求下都能保证// 根据key做hash保证相同的key进入相同的messagQueuepublic static class QueueSelector implements MessageQueueSelector {public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {String s = arg + \"\";int flag = Math.abs(s.hashCode());int no = flag % mqs.size();return mqs.get(no);}}比较严格的情况下，将tag作为顺序的标识，同一业务下，每次插入消息发送表的时候，通过业务id查询最大的tag和当前的tag比较，如果tag+1和当前的不符的话，说明还有消息未到达，需等会再消费SELECT MAX(tag) FROM m_msgsend WHERE busid='xxxxx';","filePath":"E:\\linux\\blog\\src\\main\\nodejs\\blog\\_posts\\rocketmq个人定制.md","url":"/blog/编码/rocketmq个人定制/"},{"title":"设计模式","createTime":"2018-07-29 10:27:11","categories":["设计"],"tags":["设计模式"],"content":"简述23中设计模式<!--more--># 六大原则## 单一职责原则类的功能尽量做到单一## 里氏替换原则一个子类应该可以替换掉父类并且可以正常工作## 接口隔离原则一个接口拥有的行为应该尽可能的小## 依赖倒置原则高层模块不该依赖于低层模块，二者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象## 迪米特原则一个类应该尽量不要知道其他类太多的东西## 开-闭原则对修改关闭，对扩展开放# 创建型## 1. 单例### 错误实现public class Singleton {private static Singleton singleton;private Singleton(){}public static Singleton getInstance(){if (singleton == null) {//多线程情况下这里判断会失效singleton = new Singleton();}return singleton;}}同步方法有性能问题，同步范围太小又会造成多次new### double checkpublic class Singleton {private static volatile Singleton instance;private Singleton() {}public static Singleton getInstance() {if (instance != null) {return instance;}synchronized (Singleton.class) {if (instance == null) {instance = new Singleton();}return instance;}}}避免的上面方式的明显缺点，但是java内存模型（jmm）并不限制处理器重排序，在执行instance=new Singleton()；时，并不是原子语句，实际是包括了下面三大步骤：1.为对象分配内存2.初始化实例对象3.把引用instance指向分配的内存空间这个三个步骤并不能保证按序执行，处理器会进行指令重排序优化，存在这样的情况：优化重排后执行顺序为：1,3,2, 这样在线程1执行到3时，instance已经不为null了，线程2此时判断instance!=null，则直接返回instance引用，但现在实例对象还没有初始化完毕，此时线程2使用instance可能会造成程序崩溃。### volatile作用1.保证可见性**可以保证在多线程环境下，变量的修改可见性**。每个线程都会在工作内存（类似于寄存器和高速缓存），实例对象都存放在主内存中，在每个线程要使用的时候把主内存中的内容拷贝到线程的工作内存中。使用volatile关键字修饰后的变量，保证每次修改了变量需要立即写回主内存中，同时通知所有的该对变量的缓存失效，保证缓存一致性，其他线程需要使用该共享变量时就要重新从住内存中获取最新的内容拷贝到工作内存中供处理器使用。这样就可以保证变量修改的可见性了。但volatile不能保证原子性，比如++操作。**2.提供内存屏障**volatile关键字能够通过提供内存屏障，来保证某些指令顺序处理器不能够优化重排，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。下面是保守策略插入内存屏障：- 在每个volatile写操作的前面插入一个StoreStore屏障。- 在每个volatile写操作的后面插入一个StoreLoad屏障。- 在每个volatile读操作的前面插入一个LoadLoad屏障。- 在每个volatile读操作的后面插入一个LoadLoad屏障。这样可以保证在volatile关键字修饰的变量的赋值和读取操作前后两边的大的顺序不会改变，在内存屏障前面的顺序可以交换，屏障后面的也可以换序，但是不能跨越内存屏障重排执行顺序。### 静态内部类public class Singleton {private Singleton() {}public static Singleton getInstance() {return InstanceHolder.instance;}static class InstanceHolder {private static Singleton instance = new Singleton();}}### 恶汉模式只要类加载了就会执行public class Singleton {private static Singleton instance = new Singleton();private Singleton() {}public static Singleton getInstance() {return instance;}}## 2. 静态工厂方法​ 一个工厂类，一个产品接口（其实也可以是一个抽象类，甚至一个普通的父类，但通常我们觉得接口是最稳定的，所以基本不需要考虑普通父类的情况），和一群实现了产品接口的具体产品，而这个工厂类，根据传入的参数去创造一个具体的实现类，并向上转型为接口作为结果返回public class StaticFactory {public static Map getMap(String name) {if (\"HashMap\".equals(name)) {return new HashMap();}if (\"TreeMap\".equals(name)) {return new TreeMap();}if (\"LinkedHashMap\".equals(name)) {return new LinkedHashMap();}if (\"hashMap\".equals(name)) {return new HashMap();}return null;}}## 3. 工厂方法产品的生产延迟到具体工厂实现类public class FactoryMethod {public interface Factory {public Product createProduct();}public interface Product {public void doSomething();}public static void main(String[] args) {Factory f1=()->()->System.out.println(\"product1\");Factory f2=()->()->System.out.println(\"product2\");f1.createProduct().doSomething();f2.createProduct().doSomething();}}## 4. 抽象工厂抽象工厂只是把工厂的一个方法变成多个public interface Factory {public Product createProduct1();public Product createProduct2();public Product createProduct3();}## 5. 建造者模式构造对象极其复杂，并且需要按照特定步骤，但过程又过程又比较类似。客户端不需要知道产品怎么造出来的，要新增产品只要新增builder就行了public class Builder {static public class Person{public String name;public int age;public Date birthday;}public interface PersonBuilder{public void step1();public void step2();public void step3();public Person get();}public static class BuilderManager{public static Person build(PersonBuilder builder){builder.step1();builder.step2();builder.step3();return builder.get();}}public static void main(String[] args) {PersonBuilder b1=new PersonBuilder() {private Person p=new Person();@Overridepublic void step3() {p.birthday=new Date();}@Overridepublic void step2() {p.age=2;}@Overridepublic void step1() {p.name=\"p1\";}@Overridepublic Person get() {return p;}};PersonBuilder b2=new PersonBuilder() {private Person p=new Person();@Overridepublic void step3() {p.birthday=new Date(0);}@Overridepublic void step2() {p.age=22;}@Overridepublic void step1() {p.name=\"p2\";}@Overridepublic Person get() {return p;}};Person p1=BuilderManager.build(b1);Person p2=BuilderManager.build(b2);System.out.println(p1.name);System.out.println(p2.name);}}## 6. 原型模式浅复制只复制引用，深复制复制所有属性public class Clone {public static MyBean BEAN = create();public static String name = getName(10000000);public static String name2=name+\"1\";public static String name3=name+\"2\";public static String name4=name+\"3\";public static void main(String[] args) throws ClassNotFoundException, InterruptedException {Class.forName(Clone.class.getName());ExecResult r = null;MultiThreadResult r2 = null;int count=100000;r = MultiThreadTest.calculate(\"clone\", Clone::doClone, 100,count);System.out.println(r.getResult());r2 = MultiThreadTest.getResult(Clone::doClone, 10000);System.out.println(r2.getResult());r = MultiThreadTest.calculate(\"deepClone\", Clone::deepClone, 100,count);System.out.println(r.getResult());r2 = MultiThreadTest.getResult(Clone::deepClone, 10000);System.out.println(r2.getResult());r = MultiThreadTest.calculate(\"create\", Clone::create, 100,count);System.out.println(r.getResult());r2 = MultiThreadTest.getResult(Clone::create, 10000);System.out.println(r2.getResult());}private static String getName(int length) {StringBuilder sb = new StringBuilder();for (int i = 0; i < length; i++) {sb.append(\"1\");}System.out.println(\"创建了一个长达\" + sb.length() + \"的字符串\");return sb.toString();}public static MyBean create() {MyBean bean = new MyBean();bean.setName1(name);bean.setName2(name2);bean.setName3(name3);bean.setName4(name4);MyBean son=new MyBean();son.setName1(name);son.setName1(name2);son.setName1(name3);bean.setSon(son);return bean;}public static MyBean doClone() {return BEAN.clone();}public static void deepClone() {try {ByteArrayOutputStream bo = new ByteArrayOutputStream();ObjectOutputStream oo = new ObjectOutputStream(bo);oo.writeObject(BEAN);ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());ObjectInputStream oi = new ObjectInputStream(bi);oi.read();} catch (Exception ex) {throw new RuntimeException(ex);}}}从log来看，深复制只是在单线程的情况下性能有点问题，其它的都差不多---------clone-------------执行100次:0.0408(ms)执行100,000次:4.6025(ms)10000个线程,创建耗时:15.5978(ms),执行耗时:673.3472(ms),平均耗时0.0421(ms)---------deepClone-------------执行100次:15.8698(ms)执行100,000次:413.6056(ms)10000个线程,创建耗时:10.8982(ms),执行耗时:659.5116(ms),平均耗时0.0583(ms)---------create-------------执行100次:0.0718(ms)执行100,000次:3.9428(ms)10000个线程,创建耗时:7.4955(ms),执行耗时:628.8875(ms),平均耗时0.0306(ms)# 结构型## 7. 代理模式改变原有方法的某些行为，参考[spring aop](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop)cglib动态代理，通过MethodInterceptor拦截原有方法import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.LazyLoader;import org.springframework.cglib.proxy.MethodInterceptor;public class MockUtil{public static <T> T mock(Class<T> clazz,MethodInterceptor callback){Enhancer e=new Enhancer();e.setSuperclass(clazz);e.setCallback(callback);return (T)e.create();}}## 8. 适配器扩展类功能用于适配特定接口，实现一个可以在thread里执行的mappublic class Adapter {static public class RunableMap extends HashMap implements Runnable {@Overridepublic void run() {System.out.println(this.keySet());}}public static void main(String[] args) throws InterruptedException {RunableMap map=new RunableMap();map.put(\"1\", \"1\");map.put(\"2\", \"1\");map.put(\"3\", \"1\");map.put(\"4\", \"1\");new Thread(map).start();}}## 9. 装饰器给类动态添加方法，例如给HttpServletRequest添加setParam使用适配器要求接口不变，而且要用新增的方法有需要知道实际的实现类，所以用的场景不大public class Decorator {public interface Person{public void say();public void sleep();}static public class DefaultPerson implements Person{@Overridepublic void say() {System.out.println(\"hello\");}@Overridepublic void sleep() {System.out.println(\"zzzzzz\");}}static public class PersonDecorator implements Person {private Person person;public PersonDecorator(Person person) {this.person=person;}@Overridepublic void say() {person.say();}@Overridepublic void sleep() {person.sleep();}public void run() {System.out.println(\"running\");}}public static void main(String[] args) {Person p=new PersonDecorator(new DefaultPerson());PersonDecorator dp=(PersonDecorator)p;dp.run();}}## 10.桥接模式将一部分要变化的内容抽象出来，主要执行类不变，当需要执行不同操作时，放入不同的implement汽车要换 变速器 只需要传入不同的Transmissionpublic class Bridge {public interface Impl {public void doMethod();}static class Holder {private Impl impl;public void setImpl(Impl impl) {this.impl = impl;}public void operation() {impl.doMethod();}}public static void main(String[] args) {Impl impl1=()->System.out.println(\"impl1\");Impl impl2=()->System.out.println(\"impl2\");Holder h=new Holder();h.setImpl(impl1);h.operation();h.setImpl(impl2);h.operation();}}## 11. 组合模式不用看了，就是一棵树public class Composite {public class TreeNode {List<TreeNode> children;String id;String name;}}## 12. 享元系统中存在一些可以用key区分的相似对象，主要用在于节约内存WPF的属性系统是我看到对享元模式最好的使用public class Flyweight {static public class FlyweightFactory {private static Map<String,Flyweight> map = new ConcurrentHashMap();public static Flyweight getFlyweight(String key) {Flyweight f=map.get(key);if(f==null) {f=new Flyweight();map.put(key, f);}return f;}}}## 13. 门面模式对外提供一个统一访问接口public class Facade {public class ClassA {public void doSomething() {}}public class ClassB {public void doSomething() {}}public class ClassC {public void doSomething() {}}public class ClassFacade {private ClassA a=new ClassA();private ClassB b=new ClassB();private ClassC c=new ClassC();public void invokeA() {a.doSomething();}public void invokeB() {b.doSomething();}public void invokeC() {c.doSomething();}}}# 行为型## 14. 观察者发布/订阅，生产/消费public class Observer {public interface Observe{public void update(Observable ob);}public static class Observable {List<Observe> observers = new ArrayList<Observe>();private String name;public void addObserver(Observe o) {observers.add(o);}public void changed() {name=name+\"changed\";notifyObservers();// 通知观察自己的所有观察者}public void notifyObservers() {for (Observe observer : observers) {observer.update(this);}}}public static void main(String[] args) {Observable ob=new Observable();ob.name=\"被观察者\";ob.addObserver(oo->System.out.println(\"a看到了:\"+oo.name));ob.addObserver(oo->System.out.println(\"b看到了:\"+oo.name));ob.changed();}}## 15. 模板方法模板规定好所有要做到事和步骤，具体类继承后实现或改变其中部分行为abstract public class TemplateMethod {public void invoke() {this.step1();this.step2();this.step3();this.step4();}void step1() {};void step2() {};void step3() {};void step4() {};static public class Implement extends TemplateMethod{public void step3() {System.out.println(\"步骤3要做到事情是。。。\");}}public static void main(String[] args) {TemplateMethod method=new Implement();method.invoke();}}## 16. 命令模式将要做的工作封装在一个类里面发送方只管发命令，命令谁执行，怎么执行不用管可以和观察者模式结合，将观察者update方法的参数封装成一个命令，就实现事件驱动了public class Command {public static class Invoker{private Manager manager;public void pushCommand(Cmd cmd) {manager.comds.add(cmd);}}static public class Manager{List<Cmd> comds=new ArrayList();private Employer employer;public void assign(){Cmd cmd=comds.remove(0);employer.doCommand(cmd);}}public static class Employer{String name;public void doCommand(Cmd cmd) {System.out.println(name+\"开始工作\");cmd.run();}}public interface Cmd{public void run();}public static void main(String[] args) {Cmd cmd1=()->System.out.println(\"cmd1\");Cmd cmd2=()->System.out.println(\"cmd2\");Cmd cmd3=()->System.out.println(\"cmd3\");Manager mg=new Manager();mg.employer=new Employer();mg.employer.name=\"员工A\";Invoker i=new Invoker();i.manager=mg;i.pushCommand(cmd1);i.pushCommand(cmd2);i.pushCommand(cmd3);mg.assign();mg.assign();}}## 18. 状态根据状态不同，行为也不同public class State {public static class Person{Stat st;public void say(String word) {System.out.println(st.getWord(word));}}static public enum Stat{a(1),b(2),c(3);int count;Stat(int count) {this.count=count;}public String getWord(String word) {StringBuilder sb=new StringBuilder();for(int i=0;i<count;i++) {sb.append(word+\",\");}return sb.toString();}}public static void main(String[] args) {Person p=new Person();p.st=Stat.a;p.say(\"hello\");p.st=Stat.b;p.say(\"hello\");p.st=Stat.c;p.say(\"hello\");}}## 19. 责任链将要做的是组合成一个责任链，让每个对象都有机会执行，参考springMVC的HandlerIterceptor任务可以所以组合，注意别搞成死循环了public class Chain {public static void main(String[] args) {Handler h1=new Handler() {@Overrideboolean doSomething(Request req) {req.message=req.message+\":h1\";return true;}};Handler h2=new Handler() {@Overrideboolean doSomething(Request req) {req.message=req.message+\":h2\";return true;}};Handler h3=new Handler() {@Overrideboolean doSomething(Request req) {req.message=req.message+\":h3\";return true;}};h1.setNext(h2);h2.setNext(h3);Request req=new Request();req.message=\"begin\";h1.handle(req);System.out.println(req.message);}}## 20. 中介者当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时涉及很多其他对象的行为，可使用中介者模式。## 21. 策略模式流程基本固定，通过给方法传递一个接口，改变计算方式public class Strategy {public interface Method{public void invoke();}public void run(Method method) {method.invoke();}public static void main(String[] args) {Method m1=()->System.out.println(\"执行方法1\");Method m2=()->System.out.println(\"执行方法2\");Strategy st=new Strategy();st.run(m1);st.run(m2);}}## 22. 备忘录将数据在对象外部保存，以便恢复到特定状态public class Memento {static public class Person{String memory;Integer age=3;}public static void main(String[] args) {Person p=new Person();p.memory=\"3岁的记忆\";p.age=3;//备份Map map=new HashMap();map.put(\"age\", p.age);map.put(\"memory\", p.memory);//删除p.memory=\"\";p.age=null;//恢复p.memory=(String) map.get(\"memory\");p.age=(Integer) map.get(\"age\");}}## 23. 迭代器 定义：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。# 模式个人理解## 代理VS装饰器- 从语意上讲，代理模式是为控制对被代理对象的访问，而装饰模式是为了增加被装饰对象的功能- 代理类所能代理的类完全由代理类确定，装饰类装饰的对象需要根据实际使用时客户端的组合来确定- 被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象由客户端创建并传给装饰对象## 策略VS状态VS桥接VS责任链VS命令VS观察者考虑以下场景public class A {private List bs;public void prepare(B b) {bs.add(b)}public void run(C c) {for(B impl:list) {b.invoke(c)}}}有一个主业务类A，它执行run方法之前，会传进来1个或几个B，我们能确定的是客户端在调用run方法前会先调用prepare方法。至于如何调用，调用方式，不同场景会有不同#按顺序a.prepare(b1)；a.prepare(b2)a.prepare(b3)；a.run(c1)；a.run(c2);#间隔a.prepare(b1);a.run(c1);a.prepare(b2);a.run(c2);#不确定a.prepare(b1);a.run(c1);a.prepare(b2);a.prepare(b3);a.run(c2);编码是通常考虑的是：1. A里存的B是1个还是多个2. B的个数是固定的，还是可以任意添加删除3. B内部是否要保存状态4. 不同B的实现类之间需要互相知道彼此吗5. 不同B之间是否有优先级6. 参数c是否要在各个b之间传递7. 是否需要通过调用返回值判断是否继续下一个调用换成设计模式的语言就是这样的:st=>start: 开始cond=>condition: B在A中有多个cond-1=>condition: B由客户端指定end0=>end: 状态模式cond0=>condition: B间通信op0=>operation: B自己确定下个Bop=>operation: B是A的一部分cond2=>condition: B是简单算法end1=>end: 策略模式end2=>end: 桥接op3=>通常由C主导任务cond3=>condition: run后移除Bend3=>end: 命令模式cond4=>condition: B相互独立end4=>end: 观察者op5=>operation: C在B间传递end5=>end: 责任链st->condcond(no,right)->cond-1cond-1(no,right)->op0->end0cond-1(yes)->cond2cond2(yes,right)->end1cond2(no)->op->end2cond(yes)->cond3cond3(yes,right)->end3cond3(no)->cond4cond4(yes,right)->end4cond4(no)->op5op5->end5","filePath":"E:\\linux\\blog\\src\\main\\nodejs\\blog\\_posts\\设计模式.md","url":"/blog/设计/设计模式/"}]